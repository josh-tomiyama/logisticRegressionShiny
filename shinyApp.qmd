---
title: "Supplemental Dashboard: Optimizing Expected Revenue"
date: "2026-01-20"
description: "A dashboard to supplement and summarize the Optimizing Expected Revenue project"
categories:
  - "R Shiny"
  - "Dashboard"
  - "Machine Learning"
  - "Logistic Regression"
  - "Optimization"
format: 
  html:
    page-layout: custom
image: "./preview.png"
filters: 
  - shinylive
---

::: panel-tabset
# Notes

This dashboard is a supplement to the project article ["Logistic Regression Analysis Example: Optimizing Expected Revenue"](../optimizingExpectedReturns/index.qmd){target="_blank"}. More details on model building is discussed there, but results and general summary of the data are presented here.

The dashboard below is created with R shinylive to allow online publishing of the application without using a dedicated server. Instead, the application will use the computing resources of the user viewing the app. **This may result in a long initial loading time**.

Source code to run app locally is found [in this repository](https://github.com/josh-tomiyama/logisticRegressionShiny/tree/main/test){target="_blank"}. If you have R and Rstudio installed, then it would be bit faster to run the app locally than on a web browser.

# Data Dictionary

-   `sold` - The outcome of interest. 0 indicates failed sale, 1 indicates successful sale

-   `type` - The product type. Can be either of 'accessories', 'shoes', 'clothes'.

-   `cost` - The cost to produce the product in USD.

-   `markup` - The markup percentage. A value of 20 indicates a 20% markup for sales.

# Model Used

The logistic regression model with the following formula:

$$
  \log(\frac{\pi_i}{1 - \pi_i}) = \beta_0 + x_{markup} * \beta_{markup} + 
x_{cost} * \beta_{cost} + x_{type=shoes} * \beta_{type=shoes} + x_{type = clothes}*\beta_{type = clothes}
$$

# Packages Used

```{r libraries}
#| eval: false
library(shiny)
# Note: shinylive does not need to be loaded, only installed locally
library(shinylive)
library(bslib)
library(reactable)
library(dplyr)
library(ggplot2)
library(future.apply)
library(scales)
library(knitr)
library(kableExtra)
library(gt)
library(gtsummary)
library(plotly)
library(bsicons)
library(htmltools)
```

:::

## Dashboard

```{shinylive-r}
#| standalone: TRUE
#| viewerHeight: 800
library(shiny)
library(bslib)
library(reactable)
library(dplyr)
library(ggplot2)
library(future.apply)
library(scales)
library(knitr)
library(kableExtra)
library(gt)
library(gtsummary)
library(plotly)
library(bsicons)
library(htmltools)
# Create Input Data-------------------------------------------------------------

## True parameter values

set.seed(2013)

sample_size <- 3000

true_beta <- c(2, # intercept
               -0.2, # markup
               0.002, # cost
               1, # type=clothes
               1.5 )# type=shoes

### Simulate data

type <- sample(c("accessories", "clothes", "shoes"), 
               size = sample_size,
               replace = TRUE,
               prob = c(0.3, 0.5, 0.2))
cost <- rnorm(sample_size, mean = 2000, sd = 400)
markup <- runif(sample_size, min = 20, max = 120)

## make sure markup and cost are above 0
markup <- ifelse(markup <= 0, 10, markup)
cost <- ifelse(cost <= 0, 2000, cost)

# convert type into a factor variable to prepare for analysis

type <- factor(type, levels = c("accessories", "clothes", "shoes"))

x_df <- data.frame(markup = markup, cost = cost, type = type)

# get x_matrix

x_matrix <- model.matrix(~ 1 + markup + cost + type, data = x_df)

#simulated log-odds per person

log_odds <- x_matrix %*% true_beta

#convert log_odds to probabilities

inverse_logit <- function(x){(1 + exp(-x))^-1}
true_probs <- inverse_logit(log_odds)

# get the outcome
sold <- rbinom(sample_size, 1, true_probs)
x_df$sold <- sold

#-------------------------------------------------------------------------------

# Fit model and confidence intervals--------------------------------------------

fit <- glm(sold ~ 1 + markup + cost + type, 
           data = x_df,
           family = binomial)

ci <- suppressMessages(confint(fit))

#-------------------------------------------------------------------------------

# Probability plot--------------------------------------------------------------
getMode <- function(x){
  lx <- levels(x)
  ux <- unique(lx)
  factor(ux[which.max(tabulate(match(lx, ux)))], levels = lx)
}
#-------------------------------------------------------------------------------

# Exp Return and Prob Plot------------------------------------------------------
expected_return <- function(markup, cost, type, fit, log = FALSE){
  new_data <- data.frame(markup = markup,
                         cost = cost,
                         type = type)
  
  if(log){
    ### when doing optimization, the log scale is more stable if there are convergence issues
    ### need to restrict if markup > 0
    log(1 + markup/100) + log(cost) + 
      log(predict(fit, newdata = new_data, type = "response"))
  }else{
    (1 + markup/100)*cost * #total sale price
      predict(fit, newdata = new_data, type = "response") #prob success 
  }
}

expected_return_ci <- function(markup, cost, type, fit){
  new_data <- data.frame(markup = markup,
                         cost = cost,
                         type = type)
  preds <- predict(fit, newdata = new_data, se.fit = TRUE)
  preds_ci_upr <- preds$fit + qnorm(0.975)*preds$se.fit
  preds_ci_lwr <- preds$fit - qnorm(0.975)*preds$se.fit
  
  c("ci_upr" = (1 + markup/100)*cost * #total sale price
               inverse_logit(preds_ci_upr), #CI prob success 
    "ci_lwr" =   (1 + markup/100)*cost * #total sale price
               inverse_logit(preds_ci_lwr)  #CI prob success 
    ) 

}

# Revenue Graph

#-------------------------------------------------------------------------------

# Apply Optimal Markup ---------------------------------------------------------

calc_optimal_markup <- function(cost, type, fit){
  optim(par = 20, 
        fn = expected_return, 
        method = "BFGS",
        control = list(fnscale = -1), # do maximization not minimization
        # These params don't change
        cost = cost, type = type, fit = fit 
  )  
}


# non-parallel (sequential) version

# optimal_markups <- mapply(calc_optimal_markup,
#                           cost = x_df$cost,
#                           type = x_df$type,
#                           MoreArgs = list(fit = fit)
#                           )


# set up parallel computing
plan("multisession")
# do the calculation for every data point in parallel
# on my machine this speeds up the calculation about 6 fold
optimal_markups <- future_mapply(calc_optimal_markup, 
                                 cost = x_df$cost, 
                                 type = x_df$type, 
                                 MoreArgs = list(fit = fit)
)
# return computing environment back to normal
plan("sequential")

optimal_x_df <- x_df
optimal_x_df$markup <- unlist(optimal_markups[1,])

## predicted probabilities with optimal markup
hypothetical_probs <- predict(fit, 
                              newdata = optimal_x_df, 
                              type = 'response')

### simulate whether a sale was made for the optimal markup data set, 5000 times
set.seed(2013)
expected_results <- replicate(5000,
                              expr = {
                                hypothetical_success <- rbinom(sample_size, 1, hypothetical_probs)
                                c(change_sales = sum(hypothetical_success) - sum(x_df$sold),
                                  change_rev = sum(hypothetical_success * (1 + optimal_x_df$markup/100)*x_df$cost) - 
                                    sum(x_df$sold * (1 + x_df$markup/100)*x_df$cost)
                                )
                              })

## create table of observed and optimal results
obs_revenue <- sum(x_df$sold * (1 + x_df$markup/100)*x_df$cost)
optimal_results <- data.frame(observed = c(sum(x_df$sold), obs_revenue),
                              sim_ave = c(floor(mean(expected_results[1,])),
                                          mean(expected_results[2,]))
)

optimal_results <- optimal_results %>%
  mutate(percent_change = 
           ifelse(sim_ave/observed > 1, 
                  sim_ave/observed - 1, 
                  1 - sim_ave/observed),
         difference = sim_ave - observed
  )
rownames(optimal_results) <- c("Sales", "Revenue")
## format dollars and percentages as they are hard to read otherwise
optimal_results$percent_change <- scales::percent(optimal_results$percent_change, 
                                                  accuracy = 1, 
                                                  decimal.mark = ".")
optimal_results[2, c(1, 2, 4)] <- 
  dollar(unlist(optimal_results[2, c(1, 2, 4)]), 
         accuracy = 0.01, 
         scale = 1/1e6, 
         prefix = "$", 
         suffix = " M")

## print results
optimal_results %>% 
  kable(digits = 2, align = 'c') %>%
  kable_styling() %>%
  footnote(number = "Revenue Rounded to nearest 0.01 Million Dollars")

# Define UI ----
ui <- page_fluid(
  titlePanel("Supplemental Dashboard for Optimal Markup Strategy"),
  navset_tab(
    nav_panel("Data Summary",
                  ## top row be histograms/barplots of data
                  card(full_screen = TRUE,
                       card_header("Distribution of Markup Percentage"),
                       card_body(
                         inputPanel(
                           selectInput("select_markup",
                                       "Split By Category:",
                                       list("None" = "none", 
                                            "Type" = "type", 
                                            "Sold" = "sold")
                           ),
                           sliderInput("nbin_markup", "Number of Bins:", 
                                       min = 5, max = 100,
                                       value = ceiling( 
                                         diff(range(x_df$markup)) /
                                           (2*IQR(x_df$markup)/(nrow(x_df))^(1/3)
                                           )
                                       )
                           ) 
                         ),
                         layout_column_wrap(
                         card(full_screen = TRUE,
                              plotOutput("hist_markup")),
                         card(full_screen = TRUE,
                              gt_output("table_markup"))
                       )
                  )
                  ),
                  card(full_screen = TRUE,
                       card_header("Distribution of Cost"),
                       card_body(
                         inputPanel(
                           selectInput("select_cost",
                                       "Split By Category:",
                                       list("None" = "none", 
                                            "Type" = "type", 
                                            "Sold" = "sold")
                           ),
                           sliderInput("nbin_cost", "Number of Bins:", 
                                       min = 5, max = 50, 
                                       value = ceiling( 
                                         diff(range(x_df$cost)) /
                                           (2*IQR(x_df$cost)/(nrow(x_df))^(1/3))
                                       )
                           )
                         ),
                         layout_column_wrap(
                         card(full_screen = TRUE,
                                plotOutput("hist_cost")
                              ),
                         card(full_screen = TRUE,
                                gt_output("table_cost")
                              )
                         )
                       )
                  ),
                  card(full_screen = TRUE,
                       card_header("Distribution of Product Type"),
                       card_body(
                         inputPanel(
                           checkboxInput("type_by_sold", "By sold:", FALSE)
                         ),
                         layout_column_wrap(
                           card(full_screen = TRUE,
                                  plotOutput("bar_type")
                           ),
                           card(full_screen = TRUE,
                                  gt_output("table_type")
                           )
                         )
                       )
                  ),
                  card(full_screen = TRUE,
                       card_header("Distribution of Sold Products"),
                       card_body(
                         inputPanel(
                           checkboxInput("sold_by_type", "By type:", FALSE)
                         ),
                         layout_column_wrap(
                           card(full_width = TRUE,
                                plotOutput("bar_sold")
                                ),
                           card(full_width = TRUE,
                                gt_output("table_sold")
                                )
                         )
                       )
                       )
              # markup vs cost ommited for now
                  # card(full_screen = TRUE,
                  #      card_header("Markup vs Cost"),
                  #      card_body(plotOutput("plot_markup_cost"))
                  # )
                )
              ,
    nav_panel("Expected Revenue Calculator",
              # Revenue Highlights Here
              card( "Optimal Revenue Highlights",
                    card_body(
                      layout_column_wrap(
                        value_box("Projected Revenue Increase",
                                  value = optimal_results$difference[2],
                                  showcase = bs_icon("currency-dollar"),
                                  span(bs_icon("arrow-up"), paste0(optimal_results$percent_change[2], " vs. Current Revenue")),
                                  # paste0(optimal_results$percent_change[2], " Increase over Observed"),
                                  theme = 'green'
                                  ),
                        value_box("Projected Sales Increase",
                                  value = paste0(optimal_results$difference[1], "products"),
                                  showcase = bs_icon("bag-check"),
                                  span(bs_icon("arrow-up"), paste0(optimal_results$percent_change[1], " vs. Current Sales")),
                                  theme = 'green'
                                  ),
                      )
                    )
              ),
              layout_sidebar(
                ## inputs for product type and cost in sidebar
                sidebar = sidebar(
                  h3("Inputs for Optimal Markup Calculator"),
                  sliderInput("slider_markup_rev",
                              "Markup: ",
                              min = 0, 
                              max = 200,
                              value = c(0, 120)
                  ),
                  numericInput("num_cost_rev",
                               "Cost: ",
                               value = mean(x_df$cost),
                               min = 1,
                               max = 10000),
                  selectInput("select_type_rev",
                              "Type: ",
                              choices = 
                                c(
                                  "Accessories" = "accessories",
                                  "Shoes" = "shoes",
                                  "Clothes" = "clothes" 
                                )
                  )
                ),
                # main content
                layout_column_wrap(
                  card(full_screen = TRUE,
                    plotlyOutput("plot_exp_rev")),
                  card(full_screen = TRUE,
                    plotlyOutput("plot_prob_rev"))
                )
              )
            ),
    nav_panel("Interactive Raw Data",
              helpText("Values rounded to 2 decimal places"),
              reactableOutput("raw_data")),
    id = "nav_tabs"
  )

)

# Define server logic ----
server <- function(input, output) {
  
  # Data Summary Outputs -------------------------------------------------------
  base_markup <- reactive({
    ggplot(x_df, aes(markup)) + 
      geom_histogram(bins = input$nbin_markup)
  })
  
  base_cost <- reactive({
    ggplot(x_df, aes(cost)) + 
      geom_histogram(bins = input$nbin_cost)
  })
  
  base_type <- ggplot(x_df, aes(type)) + 
    geom_bar() + 
    geom_text(stat = "count", aes(label = after_stat(count)), vjust = -0.5) + 
    labs(x = "Product Type") + 
    scale_y_continuous(expand = expansion(mult = c(0.05, 0.10)))
  
  base_sold <- ggplot(x_df, aes(sold)) + 
    geom_bar() + 
    geom_text(stat = "count", aes(label = after_stat(count)), vjust = -0.5) + 
    labs(x = "Sold Products") + 
    scale_y_continuous(expand = expansion(mult = c(0.05, 0.15)))
  
  output$hist_markup <- renderPlot({
    if(input$select_markup == "type"){
      base_markup() + 
        facet_wrap(~ type, ncol = 1)
    }else if(input$select_markup == "sold"){
      base_markup() + 
        facet_wrap(~ as.factor(sold), ncol = 1)
    }else{
      base_markup()
    }
  })
  
  output$hist_cost <- renderPlot({
    if(input$select_cost == "type"){
      base_cost() + 
        facet_wrap(~ type, ncol = 1)
    }else if(input$select_cost == "sold"){
      base_markup() + 
        facet_wrap(~ as.factor(sold), ncol = 1)
    }else{
      base_markup()
    }
  })
  
  output$bar_type <- renderPlot({
    if(input$type_by_sold){
      base_type + facet_wrap(~as.factor(sold), ncol = 1) 
    }else{
      base_type
    }
  })
  
  output$bar_sold <- renderPlot({
    if(input$sold_by_type){
      base_sold + facet_wrap(~as.factor(type), ncol = 1) 
    }else{
      base_sold
    }
  })
  
  output$table_markup <- render_gt(
    
    if(input$select_markup == "type"){
      x_df %>%
        tbl_summary(
          include = c(markup),
          type = list(all_continuous() ~ "continuous2"),
          statistic = list(
            all_continuous() ~ c("{mean} ({sd})", "{median} ({p25}, {p75})", "[{min}, {max}]")
          ),
          by = type) %>% 
        as_gt()
    } else if(input$select_markup == "sold"){
      x_df %>%
        tbl_summary(
          include = c(markup),
          type = list(all_continuous() ~ "continuous2"),
          statistic = list(
            all_continuous() ~ c("{mean} ({sd})", "{median} ({p25}, {p75})", "[{min}, {max}]")
          ),
          by = sold) %>% 
        as_gt()
    }else{
      x_df %>%
        tbl_summary(
          include = c(markup),
          type = list(all_continuous() ~ "continuous2"),
          statistic = list(
            all_continuous() ~ c("{mean} ({sd})", "{median} ({p25}, {p75})", "[{min}, {max}]")
            )
          ) %>% 
        as_gt()
    }
  )
    
  output$table_cost <- render_gt(
    
    if(input$select_cost == "type"){
      x_df %>%
        tbl_summary(
          include = c(cost),
          type = list(all_continuous() ~ "continuous2"),
          statistic = list(
            all_continuous() ~ c("{mean} ({sd})", "{median} ({p25}, {p75})", "[{min}, {max}]")
          ),
          by = type) %>% 
        as_gt()
    } else if(input$select_cost == "sold"){
      x_df %>%
        tbl_summary(
          include = c(cost),
          type = list(all_continuous() ~ "continuous2"),
          statistic = list(
            all_continuous() ~ c("{mean} ({sd})", "{median} ({p25}, {p75})", "[{min}, {max}]")
          ),
          by = sold) %>%
        as_gt()
    }else{
      x_df %>%
        tbl_summary(
          include = c(cost),
          type = list(all_continuous() ~ "continuous2"),
          statistic = list(
            all_continuous() ~ c("{mean} ({sd})", "{median} ({p25}, {p75})", "[{min}, {max}]")
          )
        ) %>% 
        as_gt()
    }
  )
  
  output$table_type <- render_gt(
    
    if(input$type_by_sold){
      x_df %>%
        tbl_summary(
          include = c(type),
          type = list(all_categorical() ~ "categorical"),
          by = sold) %>% 
        as_gt()
    }else{
      x_df %>%
        tbl_summary(
          include = c(type),
          type = list(all_categorical() ~ "categorical")
        ) %>% 
        as_gt()
    }
  )
  
  output$table_sold <- render_gt(
    
    if(input$sold_by_type){
      x_df %>%
        tbl_summary(
          include = c(sold),
          type = list(all_categorical() ~ "categorical"),
          by = type) %>%
        as_gt()
    }else{
      x_df %>%
        tbl_summary(
          include = c(sold),
          type = list(all_categorical() ~ "categorical")
        ) %>%
      as_gt()
    }
  )
  
  output$plot_markup_cost <- renderPlot(
    plot(markup, cost, 
         main = "cost vs markup", 
         ylab = "cost of production ($)", 
         xlab = "markup of product (%)")
  )
  
  
  # Optimal Markup Outputs -----------------------------------------------------
  
  x_markup_vals <- reactive({
    seq(input$slider_markup_rev[1],
        input$slider_markup_rev[2],
        by = 0.1)
  })
  
  optimal_markup_vals <- reactive({
    calc_optimal_markup(input$num_cost_rev, input_type_rev(), fit = fit)
  })
  
  input_type_rev <- reactive({
    factor(input$select_type_rev, levels = levels(x_df$type))
  })
  
  output$plot_exp_rev <- renderPlotly({
    exp_return_vals <- sapply(x_markup_vals(),
                              expected_return,
                              cost = input$num_cost_rev,
                              type = input_type_rev(),
                              fit = fit,
                              log = FALSE)
    exp_return_ci <- sapply(x_markup_vals(),
                            expected_return_ci,
                            cost = input$num_cost_rev,
                            type = input_type_rev(),
                            fit = fit)
    exp_return_df <- data.frame(x = x_markup_vals(),
                                y = exp_return_vals,
                                ci_lwr = exp_return_ci[2,],
                                ci_upr = exp_return_ci[1,])
    optimal_markup_df <- data.frame(x_opt = optimal_markup_vals()$par,
                                    y_opt = optimal_markup_vals()$value)
    exp_rev_plot <-
      ggplot(exp_return_df, aes(x = x)) +
      geom_line(aes(y = y, col = "Exp Revenue")) +
      geom_ribbon(aes(ymin = ci_lwr, ymax = ci_upr, fill = "95% CI"), alpha = 0.2) +
      geom_point(aes(x = x_opt,
                     y = y_opt,
                     col = "Optimal Markup"), data = optimal_markup_df) + 
      scale_colour_manual(values = c("black", "green"), name = c("")) +
      scale_fill_manual(values = 'red', name = "") +
      ggtitle(paste0("Expected Revenue vs Markup Percentage")) +
      labs(x = "markup (%)",
           y = "Expected Revenue ($)") +
      theme(legend.spacing = unit(0, "pt"),
            legend.margin = margin(t =-16, r = 0, b = -4, l = 0, unit = "pt")
      )
    exp_rev_plotly <-
      ggplotly(exp_rev_plot)
    
    # ### manually rename plotly elements back to defaults
    exp_rev_plotly$x$data[[1]]$name <- "Exp Revenue"
    exp_rev_plotly$x$data[[2]]$name <- "95% CI"
    exp_rev_plotly$x$data[[3]]$name <- "Optimal Markup"
    exp_rev_plotly$x$layout$legend$title$text <- ""
    exp_rev_plotly
  }
  )
  
  output$plot_prob_rev <- renderPlotly({
    new_x_df <- data.frame("markup" = x_markup_vals(),
                           "cost" = input$num_cost_rev,
                           "type" = input_type_rev())
    
    preds <- predict(fit, newdata = new_x_df, se.fit = TRUE)
    preds_ci_upr <- preds$fit + qnorm(0.975)*preds$se.fit
    preds_ci_lwr <- preds$fit - qnorm(0.975)*preds$se.fit
    probs_df <- data.frame(pred_prob = inverse_logit(preds$fit),
                           pred_prob_lwr = inverse_logit(preds_ci_lwr),
                           pred_prob_upr = inverse_logit(preds_ci_upr),
                           markup = x_markup_vals()
                           )
    
    ## optimal point
    
    x_df_opt <- data.frame("markup" = optimal_markup_vals()$par,
                           "cost" = input$num_cost_rev,
                           "type" = input_type_rev())
    
    probs_df_opt <- data.frame(x_opt = optimal_markup_vals()$par,
                               y_opt = predict(fit, 
                                               newdata = x_df_opt, 
                                               type = 'response')
                               )
    
    # true_probs <- model.matrix(~ markup + cost + type, data = new_x_df) %*% true_beta
    # probs_df$true_probs <- inverse_logit(true_probs)
    
    est_prob_plot <- ggplot(probs_df, aes(x = markup)) +
      ## probability curve predicted from logistic regression in black
      geom_line(aes(y = pred_prob, col = 'Est Prob')) +
      geom_ribbon(aes(ymin = pred_prob_lwr, ymax = pred_prob_upr, fill = "95% CI"), alpha = 0.2) +
      geom_point(aes(x = x_opt,
                     y = y_opt,
                     col = "Optimal Markup"), data = probs_df_opt) +
      scale_colour_manual(values = c("black", "green"), name = c("")) +
      scale_fill_manual(values = "red", name = "") +
      ggtitle(paste0("Probablity of Selling Product vs Markup Percentage")) +
      labs(x = "markup (%)",
           y = "Probability of Selling Product") +
      theme(legend.spacing = unit(0, "pt"),
            legend.margin = margin(t =-16, r = 0, b = -4, l = 0, unit = "pt")
      )
    
    est_prob_pltly <- ggplotly(est_prob_plot)
    ### manually rename plotly elements back to defaults
    est_prob_pltly$x$data[[1]]$name <- "Est Prob"
    est_prob_pltly$x$data[[2]]$name <- "95% CI"
    est_prob_pltly$x$data[[3]]$name <- "Optimal Markup"
    est_prob_pltly$x$layout$legend$title$text <- ""
    
    est_prob_pltly
    }
  )
  
  # Interactive raw data
  
  output$raw_data <- renderReactable(
    reactable(x_df, 
             searchable = TRUE,
             columns = list(
               markup = colDef( 
                 format = colFormat(digits = 2, 
                                    suffix = "%")
               ),
               cost = colDef(
                 format = colFormat(currency = "USD", 
                                    digits = 2)
               ),
               type = colDef(
                 cell = function(value){
                   if(value == "clothes"){
                     "ðŸ‘• clothes"
                   }else if (value == "shoes"){
                     "ðŸ‘Ÿ shoes"
                   }else{
                     "ðŸ‘œ accessories"
                   }
                 },
                 align = "center"),
               sold = colDef(
                 style = function(value){
                   if(value){
                     list(background = "green")
                   } else
                     list(background = "red")
                 })
             ),
             defaultColDef = colDef(align = "center")
                                               
    )
  )
  
}

# Run the app ----
shinyApp(ui = ui, server = server)
```

